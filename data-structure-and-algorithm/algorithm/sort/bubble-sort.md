### 冒泡排序

> 冒泡排序是一种稳定的排序方式，当排序元素有相同的时候，它们排序前后元素的相同位置是不会发生变化的

* 冒泡排序是比较相邻两个元素的大小，如果第i个元素大于i+1个元素，那么就交换i和i+1元素的位置，如果小于，就不改变位置，继续比较i+1和i+1+1个元素，一直
重复比较，直到结束

* 举例：

```php
$arr = [3, 2, 6, 1];

// 第一次比较 3和2, 3 > 2, 交换位置 [2， 3， 6， 1] 之后比较， 3和6，3 < 6, 不交换，继续比较， 6 和 1 ， 6 > 1 ,交换位置 [2， 3， 1，6]
// 第一次循环结束，找到了最大值，把它放在最后一个元素，
$arr = [2， 3， 1，6];
// 第二次比较 2 和 3， 2 < 3 ,不交换，继续， 3 和 1 ，3 > 1 交换，[2， 1， 3，6]， 3 和 6 比较 3 < 6 不交换
// 第二次循环结束，找到了最大值，把它放在最后第二个元素，
$arr = [2， 1， 3，6]
//第三次比较 2 和 1， 2 > 1 交换 [1， 2， 3，6]，继续， 2 < 3,不交换，继续， 3 < 6 不交换，结束 [1， 2， 3，6]
//最终得到结果 [1， 2， 3，6]
```

```php
function bubble($arr = []): array
{
    if (!is_array($arr)) {
        return [];
    }

    $len = count($arr);

    if ($len <= 1) {
        return $arr;
    }

    for ($i = 0; $i < $len; $i++) {
        for ($j = 0; $j < $len - 1; $j++) {
            if ($arr[$j] > $arr[$j + 1]) {
               $tmp = $arr[$j];
               $arr[$j] = $arr[$j + 1];
               $arr[$j + 1] = $tmp;
            }
        }
    }

    return $arr;
}
```

* 以上中最大的问题是: 每一轮循环都会找到一个最大值，比如第一轮找到就是全局的最大值，而第二轮还要去和最大值比较，这是没必要的，它已经是最大了，就不需要
和它比较了，同理，每一论过后都有一个最大值，所以可以每次都可以去掉这个比较

```php
function bubble1($arr = []): array
{
    if (!is_array($arr)) {
        return [];
    }

    $len = count($arr);

    if ($len <= 1) {
        return $arr;
    }

    for ($i = 0; $i < $len; $i++) {
        //$len - 1 - $i, 每论比较的数据，都要去掉上一轮的最大值
        for ($j = 0; $j < $len - 1 - $i; $j++) {
            if ($arr[$j] > $arr[$j + 1]) {
                $tmp = $arr[$j];
                $arr[$j] = $arr[$j + 1];
                $arr[$j + 1] = $tmp;
            }
        }
    }

    return $arr;
}
```

* 考虑一种极端情况，假如这个数据就是一个排号顺序的，这个时候再去循环比较，那就是浪费资源，时间，这个时候，只需要判断，每一轮是否交换了数据，如果没有
交换数据，那就代表这已经是一个有序数组了，那就直接跳出循环，结束排序，这个优化方案中，第一轮的循环比较还是不可少的

```php
function bubble2($arr = []): array
{
    if (!is_array($arr)) {
        return [];
    }

    $len = count($arr);

    if ($len <= 1) {
        return $arr;
    }


    for ($i = 0; $i < $len; $i++) {
        $flag = false;//每一轮初始化为未交换数据
        for ($j = 0; $j < $len - 1 - $i; $j++) {
            if ($arr[$j] > $arr[$j + 1]) {
                $flag = true;//代表交换了数据
                $tmp = $arr[$j];
                $arr[$j] = $arr[$j + 1];
                $arr[$j + 1] = $tmp;
            }
        }
        //判断本轮是否交换了数据，如果没有，代表数组已经排序好，结束循环
        if (!$flag) {
            break;
        }
    }

    return $arr;
}
```